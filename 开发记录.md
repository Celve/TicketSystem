## 前言

之前在写完 README 的时候写过一份，结果在pull的时候不小心删掉了。

反正也只是记录了自己的一些负面的情绪，没有就算了吧。

我需要记得的，就是要提高自己的工程架构能力。

适度参考别人的思路~~代码~~

---

## 2022.5.7 23:50

终于在玩了好几天之后，开始着手写了。

一步一个脚印，再完善一下 README，清楚存储的思路（车票相关命令的实现还需要重新思考一下）

### 5.8 15:00

开始写 Account.h 了。因为吴老师的 Bptree 接口还没写好，所以我可以先用之前的块状链表来实现，最后再修改回来即可。

> 因为实际上 Bptree 和块状链表要实现的功能时一样的

> 在参考书店的同时，还要进行一些优化

**题外话**：我突然又想到，其实这里的块状链表、BpT 的作用和 map 是一样的，只不过实现的复杂度不一样

我写好的 Ull 实际上是一个 string 到 int 的 map，用来保存索引文件，并且 string 按照大小排列，查找更快

**大致思路**：先在索引文件里找到对应的位置，然后到 MemoryRiver 中访问原数据，进而进行对应操作

补充：原本书店中，刘祎禹把 user_ID 封装为一个 struct，并且重载了不等号。虽然 char[] 没有默认的比较函数，但是，我在 ull_node 中已经重载了比较函数，所以他的操作是不必要的

林超凡学长把 `ull username_to_pos` 和 `MemoryRiver user_data` 封装成了一个 `BpTree user_database`，代表`username -> User`，这样确实可以简化插入的操作

---

### 5.17 22:30

过了好久，才继续开始写...这十天，毫不夸张地说，我都在玩。

收拾心情，继续努力！

涉及到 day_train 和 station 的存储，注意到 day_train 的 ull 中，要新设定一种string的关键字

- 可以采用 train_ID + Timetype , 复合的pair？现在先直接 用连接的字符串 来代替
- 和吴老师交流，可以用 hash 把 string 先映射成 int ，然后放在 `int -> int` 的 bpt中。
- 钟老师采用的是将 train_ID 封装成一个 类，在里面存储了所有信息？
- `clean` 操作如何实现？自己重写/巧用init？ 可以直接用 out 方式打开，就可以暴力清空，然后记得init
- 表述有问题，返回值实际上指的是输出这段文字......注意结尾的换行符
- 修改一下，读取参数的string tp--->opt ，**命名规范**

> parameter：参数     qualifiers：限定符

> 比如 add -s abc ，那么 -s 称为 option， abc 称为 arguments

复习了一下友元的使用，以及static ~~上学期学的全部忘记了~~

1. 可以使用友元函数/友元类，在被访问的类中主动声明
2. static有两种：静态函数/变量，以及静态成员
    - 静态函数：该函数只能在这个文件里面调用，只能访问静态成员
    - 静态成员：所有该类的对象公用的一个成员

---
2022.5.19 18:50

因为还没有写区间查询，所以 `query_ticket` 会跑得非常慢，因为只能去 `train_data` 里面暴力遍历

而学长的优化是直接在 `station_data` 中区间查找，查找关键字包含 s/t 的元素，进而可以加快速度

优化写法，\n + string 可以避免行末换行符的特判

如何使查询的车票按关键字排序？

- bookstore的写法是建立不同关键字的 ull，
- 而这里的写法是先全部读取出来，一一判断后放入临时数组中，最后直接按照关键字 sort

第二复杂的 `query_ticket` 终于 “借鉴” 完了，花了2小时......

还剩下最复杂的 `transfer`...

---

## 2022.5.21

钟老师说，存储的字符数组要开32，因为 linux 下，汉字的编码是 UTF-8，有3字节

还是把之前独立的 `Order.h` 合并回来

注意，`query_seat` 和 `modify_seat` 应该是 `l -> r-1`，因为最后一站不需要考虑上车

`station index` 直接去 `train` 里面找比较快，因为 `train_ID` 是已知的

`buy_ticket` 的实现可以 不用 `query_ticket`，加快速度

因为 `price_sum[1] = 0`，所以求区间和的时候不用 下标-1

MD，`refund_ticket` 也难写的一笔，因为我还是用memory_river，写起来太繁琐了...

可以说，如果不是参考学长的代码，我几乎是很难想到一些细节...

今天感觉有点累，还剩下 `query_transfer` 和 `rollback`。把 transfer 写完，先过基本的数据，再发给吴老师改把

---

5.22

终于知道 `main.cpp` 无法运行，`multiple_defination` 的原因了。

> 如果在头文件中定义全局变量/函数，那么要在cpp中定义，而在h中用 `extern` 声明。要把 hpp 拆成 h 和 cpp

> 如果使用 hpp，就要保证只被一个cpp引用。

> 引用相当于直接复制代码，h文件中只能有声明，

调试小技巧：把所有代码注释掉，每次放一行，就可以判断是哪里出问题

1. `Train_system` 中的maxn 太大了？改成1000就可以了？
2. `query_profile` 不能从 `login_pool` 中查找，因为可能被查询用户没有登录......
3. 字符数组一定要开大一点，不能因为长度是20就开20，否则无法读入末尾的 `'\0'`
4. `Train_system` 忘了写构造函数...也就是没有新建文件...
5. 某些地方的date忘记补全为 "xx-xx xx:xx" 的格式化字符串
6. 我的`TimeType` 有问题，没有特判 `24:00` 的情况
7. 为了避免排序，order的key要改成 ID+user_name(顺序呼唤)
- [ ] 之后应该把 key 修改成 pair<ID, name>，按照第一个关键字排序。现在先用暴力 sort 代替
8. `query_train`如果-d不在发售日期内，直接返回-1 ！ 需要特判
9. 要保证 **查询** 时，读入的日期在 06-01 --> 08-31
10. 大数组一定要在函数外声明，防止爆栈！
11. `transfer` 中，考虑维护一个 first_time，表示第一段的时间，如果它小，说明 train1_ID 也小
12. `maxn = 1e5`，会 `Segmentation fault`，注意到生成的可执行文件在 `cmake-build-debug` 中，用命令行跑，发现 `query_train` 写错了

---

2022.5.28

要加速了，赶紧写完。这几天都没动。

1. 直接用命令行 `make`  + 'cmake'
2. 之前条件断点写错了，是 'int == 111' 而不是 “111”......
3. 不知道为什么一旦进入 `query_transfer` 函数就会 stack overflow，应该是之前的函数出错了
   
   少开一点vector?
4. `query_seat` 查询出错，座位数比实际大---> 说明是 refund 出错，但是改了还是错的？
   
   啊啊啊啊，太烦了，调不出来

   我好像明白是什么问题了，因为 `memory_river` 中的 num 并不是真正意义上的 元素个数，而是开辟的空间树=数，在删除的时候不会修改

   所以我在 ull 中定义了一个size函数，然后在总接口中保存order_num，但还是错的？

5. 难道是因为， ull 存储的 order 并不是按 order_ID 排序的？我的方法是读出来再排序

   同时要注意两次排序的差别，补票应该是早买早补，所以 pending_order是从小到大